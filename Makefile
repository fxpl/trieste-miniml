.PHONY: rebuild coverage_rep buildf buildp test clean-out

coverage ?= OFF	#Enable code coverage (ON/OFF) statistics
mode = test     #trieste mode, either 'build' or 'test'
testcount = 100 #number of tests to run in test mode
out_dir = ../coverage_trieste/miniml/coverage_reports#directory to store coverage reports
bin = ./build/miniml#path to miniml binary
cov_files := cov_tmp#directory to store output files from llvm-cov
profraw = $(cov_files)/miniml.profraw#path to raw profile data
profdata = $(cov_files)/miniml.profdata#path to profile data
llvm_cov_json = $(cov_files)/coverage_report.json#path to coverage report generated by llvm-cov
clang++_path = /opt/homebrew/Cellar/llvm@20/20.1.8/bin/clang++#path to clang++ compiler

rebuild:
	@cd build && \
	echo "Rebuilding trieste"; \
	cmake -G Ninja ../src \
	-DCODE_COVERAGE=$(coverage) \
	-DCMAKE_BUILD_TYPE=Debug \
	-DTRIESTE_BUILD_PARSER_TESTS=ON \
	-DTRIESTE_BUILD_PARSER_TOOLS=ON \
	-DCMAKE_CXX_STANDARD=20 \
	-DCMAKE_C_STANDARD=11 \
	-DCMAKE_CXX_COMPILER=$(clang++_path) \
	-DCMAKE_OSX_SYSROOT=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk \
	-DCMAKE_EXE_LINKER_FLAGS=/opt/homebrew/Cellar/llvm@20/20.1.8/lib/clang/20/lib/darwin/libclang_rt.profile_osx.a

build: clean rebuild 
	@echo "Build completed"

run: 
	@if [ -z "$(file)" ]; then \
		echo "Error: You must provide a file argument like 'make trieste_build file=your_file'"; \
		exit 1; \
	else \
		touch out/$(file).trieste && \
		echo "creating file out/$(file).trieste" && \
		$(bin) build examples/$(file).miniml -o out/$(file).trieste; \
	fi

run_pass:
	@touch out/$(file).trieste && \
	$(bin) build examples/$(file).miniml -o out/$(file).trieste -p $(p)

define generate_json
llvm-profdata merge -sparse $(profraw) -o $(profdata) && \
llvm-cov export $(bin) \
  -instr-profile=$(profdata) \
  -ignore-filename-regex='.*/build/' \
  -ignore-filename-regex='.*/passes/parse/init_parse\.cc' \
  -ignore-filename-regex='.*/main\.cc' \
  -format=text \
  -summary-only > $(llvm_cov_json)
endef

define generate_html
llvm-cov show $(bin) \
  -instr-profile=$(profdata) \
  -output-dir=cov_tmp \
  -format=html \
  -ignore-filename-regex='.*/build/' \
  -ignore-filename-regex='.*/passes/parse/init_parse\.cc' \
  -ignore-filename-regex='.*/main\.cc' \
  -show-line-counts
endef

define coverage_rep
if [ "$(mode)" = "build" ]; then \
	LLVM_PROFILE_FILE=$(profraw) $(bin) $(mode) ../examples/$(file).miniml ; \
else \
	LLVM_PROFILE_FILE=$(profraw) $(bin) $(mode) -c $(testcount) ; \
fi && \
$(generate_json) && \
$(generate_html)
endef
#TODO find a more robust way to ignore non-source files


coverage_report:
	@if [ "$(mode)" = "build" ] && [ -z "$(file)" ]; then \
		echo "Error: You must provide a file argument like 'make coverage_report file=your_file'" ; \
		exit 1; \
	else \
		echo "Generating coverage report" && $(coverage_rep) ; \
	fi

create_coverage_stats:
	@source ~/coverage_trieste/run_cov/bin/activate && \
	python3 ~/coverage_trieste/coverage_sweep.py \
	--coverage_dir $(cov_files) \
	--output_dir $(out_dir) \
	--report_path $(llvm_cov_json) && \
	deactivate
OBJECTS=$(patsubst examples/%.miniml, out/%.trieste, $(shell ls examples/*.miniml))
FAILING_OBJECTS=$(patsubst examples/fail/%.miniml, out/fail/%.trieste, $(shell ls examples/fail/*.miniml))

buildf:
	touch out/$f.trieste; ./build/miniml build examples/$f.miniml -o out/$f.trieste

buildp:
	touch out/$f.trieste; ./build/miniml build examples/$f.miniml -o out/$f.trieste -p $p

fuzz:
	@$(bin) test -f

clean-out:
	@rm -rf out/* *.trieste

clean-reports:
	@rm -rf coverage_reports/*

out:
	mkdir -p out

out/fail: out
	mkdir -p out/fail

out/fail/%.trieste: examples/fail/%.miniml | out/fail
	@build/miniml build $< -o $@ > /dev/null && echo "Failing test succeeded:" $< || true

out/%.trieste: examples/%.miniml | out
	build/miniml build $< -o $@

test: $(OBJECTS) $(FAILING_OBJECTS)

experiment: out
	python run_experiments.py

llvm: out generate-code compile-llvm

generate-code: all
	touch out/test.trieste; > out/test.trieste; ./build/miniml build llvmir_tests/test.miniml -o out/test.trieste;

compile-llvm:
# This is a test for the LLVM IR files. It compiles the LLVM IR file, runs it and prints returnval to stdout.
	clang out/test.ll -o out/test.out; ./out/test.out; echo $$?

clean:
	rm -rf out/* *.trieste; rm -rf build; rm -rf out; rm out.ll; rm compiler_output.txt

.PHONY: clean all build/miniml test